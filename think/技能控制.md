在过去,我一直把技能控制单独做成一个SkillSchedule控制类,然后将其作为其对应单位的一个元素.但是很快我就发现,技能触发时会无可避免的访问其对应单位的一些元素.比如一个技能在执行的时候需要知道其对应单位的位置.

这里出现了一个问题:一个类的元素如何访问其上层模块?最简单的方法,就是把上层的引用传递给他.但是,如果Enemy和Operator都有SkillSchedule,如果要传递引用的话要么传递两种不同类的父类Unit,要么在SkillSchedule内部针对两种子类分开处理,第二种太麻烦而且后面改起来太麻烦,我只考虑第一种.

在第一种中,由于rust没有oop,所以可以使用trait或者enum实现父类的效果,现在代码使用的是enum在实现父类的效果,但是因为数据分配在堆上的问题,Unit内部对于两种子类的表示是Rc<RefCell<Operator>>>和Rc<RefCell<Enemy>>,这里有一个大问题:我在调用SkillSchedule的方法的地方,是在Operator内部的方法内,而Operator恰恰是通过可变引用的方式调用的...所以如果在SkillSchedule内借用Operator的话,会同时出现一个可变引用和不可变引用,然后程序就挂了.

为解决可变引用和不可变引用同时存在的问题,我想过把引用替换为指针,这个改动会引起更大的问题:rust内只有裸指针而没有智能指针,智能指针类似的Rc那玩意的限制在前面也已经说了...一旦替换为智能指针,那其他地方也会炸...

于是我突发奇想:为啥要把SkillSchedule作为Operator的内部的元素?为啥不把Operator作为SkillSchedule内部的元素?这么一想,不少问题也也就解决了.尽管可能在逻辑上似乎不太直观,所以我吧SkillSchedule和Operator放在同一个层次上.

但是这又有其他问题,当一个Operator被移除时,需要把对应的SkillSchedule也一并移除,但是如何快速找到对于的SkillSchedule并且判别这个SkillSchedule,又是另一个问题...

那如果,把SkillSchedule和Operator包装成一个独立的结构体呢?把原先的Operator重构为OperatorData,然后再构建一个全新的Operator,内有SkillSchedule和OperatorData两个元素,又似乎可以了.

但是这个和最开始的方案似乎又没什么不同...而且后续可能还会有另一个问题:如果一个Operator的效果,是更改另一个Operator的sp,那又如何是好?

死来想去,再重构了一半之后,我觉得还是用一开始的样子好.并且我还萌生了一个想法,在技能触发的时候,把所有会触发的效果返回上层,然后在延迟处理,这样的话可以使每个单位的数据处理相独立,最后可以直接在此并行化