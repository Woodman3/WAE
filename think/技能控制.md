在过去,我一直把技能控制单独做成一个SkillSchedule控制类,然后将其作为其对应单位的一个元素.但是很快我就发现,技能触发时会无可避免的访问其对应单位的一些元素.比如一个技能在执行的时候需要知道其对应单位的位置.

这里出现了一个问题:一个类的元素如何访问其上层模块?最简单的方法,就是把上层的引用传递给他.但是,如果Enemy和Operator都有SkillSchedule,如果要传递引用的话要么传递两种不同类的父类Unit,要么在SkillSchedule内部针对两种子类分开处理,第二种太麻烦而且后面改起来太麻烦,我只考虑第一种.

在第一种中,由于rust没有oop,所以可以使用trait或者enum实现父类的效果,现在代码使用的是enum在实现父类的效果,但是因为数据分配在堆上的问题,Unit内部对于两种子类的表示是Rc<RefCell<Operator>>>和Rc<RefCell<Enemy>>,这里有一个大问题:我在调用SkillSchedule的方法的地方,是在Operator内部的方法内,而Operator恰恰是通过可变引用的方式调用的...所以如果在SkillSchedule内借用Operator的话,会同时出现一个可变引用和不可变引用,然后程序就挂了.

为解决可变引用和不可变引用同时存在的问题,我想过把引用替换为指针,这个改动会引起更大的问题:rust内只有裸指针而没有智能指针,智能指针类似的Rc那玩意的限制在前面也已经说了...一旦替换为智能指针,那其他地方也会炸...

于是我突发奇想:为啥要把SkillSchedule作为Operator的内部的元素?为啥不把Operator作为SkillSchedule内部的元素?这么一想,不少问题也也就解决了.

但是这又有其他问题,当一个Operator被移除时,需要把对应的SkillSchedule,如何快速找到对于的SkillSchedule,又是另一个问题...
